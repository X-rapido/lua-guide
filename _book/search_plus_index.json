{"./":{"url":"./","title":"开篇","keywords":"","body":"目录 说明 作者：刘仁奎 程序喵博客：http://www.ibloger.net Lua 官方：https://www.lua.org/home.html 在线运行：https://www.lua.org/demo.html 手册内容，个人学习过程参考：易百教程、菜鸟教程。部分内容稍有变动。 欢迎有兴趣的朋友们内容补充。 powered by Gitbook该文件修订时间： 2019-04-28 11:16:31 "},"base/Lua介绍.html":{"url":"base/Lua介绍.html","title":"Lua 介绍","keywords":"","body":"Lua 介绍 Lua 是一种用C语言编写的可扩展，轻量级的编程语言。它于1993年由Roberto Ierusalimschy，Luiz Henrique de Figueiredo和Waldemar Celes作为内部项目开始研发。 Lua 从一开始就设计成一个可以与用C语言和其他传统语言编写的代码集成的软件。 这种集成带来许多好处。 Lua 并没有尝试做C语言已经做过的事情，而是提供C语言不擅长的东西：与硬件的良好距离，动态结构，无冗余，易于测试和调试。 为此，Lua是具有安全的环境，自动内存管理以及用于处理动态大小的字符串和其他类型数据的良好工具。 一、设计目的 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。 二、Lua 特性 轻量级 轻量级Lua语言的官方版本只包括一个精简的核心和最基本的库。这使得Lua体积小、启动速度快，从而适合嵌入在别的程序里。5.0.2版的Lua的内核小于120KB。 可扩展 可扩展 Lua并不象其它许多\"大而全\"的语言那样，包括很多功能，比如网络通讯、图形界面等。但是Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。 其它特性 支持面向过程(procedure-oriented)编程和函数式编程(functional programming)； 自动内存管理； 只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象； 语言内置模式匹配； 闭包(closure)； 函数也可以看做一个值； 提供多线程（协同进程 ，并非操作系统所支持的线程）支持； 通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。 三、Lua 应用场景 游戏开发 独立应用脚本 Web 应用脚本 扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench 安全系统，如入侵检测系统 四、第一个 Lua 程序 接下来我们使用 Lua 来输出 \"Hello World!\" 实例(Lua 5.3) print(\"Hello World!\") 运行后，会在屏幕上显示 Hello, world! 五、在线运行 Lua 程序 如果你的电脑还没有安装 Lua 环境，可以使用官网地址在线执行脚本 Lua 官网执行：https://www.lua.org/cgi-bin/demo powered by Gitbook该文件修订时间： 2019-04-16 13:33:36 "},"base/Lua安装.html":{"url":"base/Lua安装.html","title":"Lua 安装","keywords":"","body":"安装 一、Windows 系统 下载方式1 进入Lua官网：http://www.lua.org ，点击 download 获取一个二进制文件 get a binary 点击左侧的 Download，选择自己需要的文件进行下载 下载方式2 直接打开下载地址：http://joedf.ahkscript.org/LuaBuilds/ ，我的演示版本：Lua-5.3.5_Win64_bin.zip 环境变量配置 解压之后有三个文件，分别是：lua 解释器、luac 编译器、lua53.dll 库文件 设置环境变量，把 Lua 的解压路径放进去。 二、Mac OS 系统 在Mac OS X上安装要在Mac OS X中构建/测试Lua，请使用以下命令 # 下载 $ curl -R -O http://www.lua.org/ftp/lua-5.3.5.tar.gz # 解压 $ tar zxf lua-5.3.5.tar.gz # 进入 $ cd lua-5.3.5 # 编译 $ make macosx test # 安装 $ make install 在某些情况下，可能没有安装 Xcode 和命令行工具。 在这种情况下，将无法使用 make 命令。从mac app store安装Xcode。 然后转到Xcode的参考，然后切换到Downloads并安装名为“Command Line Tools”的组件。完成该过程后，就可以使用make命令。 Google Code：https://code.google.com/archive/p/luaforwindows/downloads GitHub：https://github.com/rjpcomputing/luaforwindows/releases powered by Gitbook该文件修订时间： 2019-04-28 11:04:06 "},"base/Lua基本语法.html":{"url":"base/Lua基本语法.html","title":"Lua 基本语法","keywords":"","body":"Lua 基本语法 Lua 学习起来非常简单，我们可以创建第一个 Lua 程序！ 一、第一个 Lua 程序 1、交互式编程 Lua 提供了交互式编程模式。我们可以在命令行中输入程序并立即查看效果。 Lua 交互式编程模式可以通过命令 lua -i 或 lua 来启用： $ lua -i $ Lua 5.3.5 Copyright (C) 1994-2018 Lua.org, PUC-Rio > 在命令行中，输入以下 print(\"Hello World！\") 命令，接着按下回车键，输出结果如下： > print(\"Hello World！\") Hello World！ > 2、脚本式编程 我们可以将 Lua 程序代码保持到一个以 lua 结尾的文件，并执行，该模式称为脚本式编程，如我们将如下代码存储在名为 hello.lua 的脚本文件中： print(\"Hello World！\") print(\"程序喵\") 使用 lua 名执行以上脚本，输出结果为： $ lua test.lua Hello World！ 程序喵 我们也可以将代码修改为如下形式来执行脚本（在开头添加：#!/usr/local/bin/lua）： #!/usr/local/bin/lua print(\"Hello World！\") print(\"程序喵\") 以上代码中，我们指定了 Lua 的解释器 /usr/local/bin 目录。加上 # 号标记解释器会忽略它。 二、注释 1、单行注释 两个减号是单行注释 -- 2、多行注释 --[[ 多行注释 多行注释 --]] 三、标示符 Lua 表示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A-Z 或 a-z 或下划线 _ 开头后加上0或多个字母，下划线，数字（0-9）。 最好不要使用下划线加大写字母的标示符，因为 Lua 的保留字也是这样的。 Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符。 Lua 区分大小 以下列出了一些正确的标示符： mohd zara abc move_name a_123 myname50 _temp j a23b9 retVal 四、关键词 以下列出了 Lua 的保留关键字。保留关键字不能作为常量或变量或其他用户自定义标示符。 一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。 五、全局变量 在默认情况下，变量总是认为是全局的。 全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。 print(b) --> nil b=10 print(b) --> 10 如果你想删除一个全局变量，只需要将变量赋值为nil。 b = nil print(b) --> nil 这样变量 b 就好像从没被使用过一样。换句话说, 当且仅当一个变量不等于 nil 时，这个变量即存在。 powered by Gitbook该文件修订时间： 2019-04-16 14:09:18 "},"base/Lua数据类型.html":{"url":"base/Lua数据类型.html","title":"Lua 数据类型","keywords":"","body":"Lua 数据类型 Lua 是一种动态类型语言，因此变量没有类型，只有值具有类型。值可以存储在变量中，作为参数传递并作为结果返回。 一、基本类型 编号 值类型 描述 1 nil 表示一个无效值。 2 boolean 包括true和false作为值 3 number 表示双精度类型的实浮点数。 4 string 字符串由一对双引号或单引号来表示。 5 function 由 C 或 Lua 编写的函数。 6 table 表示普通数组，符号表，集合，记录，图形，树等，并实现关联数组。它可以保存任何值(除了nil)。 7 thread 表示执行的独立线路，用于执行协同程序。 8 userdata 表示任意存储在变量中的C数据结构。 我们可以使用 type 函数测试给定变量或者值的类型： print(type(\"Hello world\")) --> string print(type(10.4*3)) --> number print(type(print)) --> function print(type(type)) --> function print(type(true)) --> boolean print(type(nil)) --> nil print(type(type(X))) --> string 默认情况下，在分配值或初始化之前，所有变量都将指向 nil。在条件检查的情况下，零和空字符串认为是：true。 因此，使用布尔运算时必须小心。 1、nil（空） nil 类型表示一种没有任何有效值，它只有一个值：nil，例如打印一个没有赋值的变量，便会输出一个 nil 值： > print(type(a)) nil > 对于全局变量和 table，nil 还有一个\"删除\"作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉，如下： tab1 = { key1 = \"val1\", key2 = \"val2\", \"val3\" } for k, v in pairs(tab1) do print(k .. \" - \" .. v) end tab1.key1 = nil for k, v in pairs(tab1) do print(k .. \" - \" .. v) end nuil 类型比较 nil 作比较时应该加上：单银行 ' 或双引号 \"。 > type(X) nil > type(X) == nil false > type(X) == \"nil\" true > 这是因为 type(X)==nil 结果为 false 而 type(type(X)) 的结果是 string。 2、boolean（布尔） boolean 类型只有两个值：true（真） 和 false（假），Lua 把 false 和 nil 看作是\"假\"，其他的都为\"真\"。 print(type(true)) print(type(false)) print(type(nil)) if type(false) or type(nil) then print(\"false and nil are false!\") else print(\"other is true!\") end 以上代码执行结果如下： boolean boolean nil false and nil are false! 3、number（数字） Lua 默认只有一种 number 类型：double（双精度）类型（默认类型可以修改 luaconf.h 里的定义），以下几种写法都被看作是 number 类型： print(type(2)) print(type(2.2)) print(type(0.2)) print(type(2e+1)) print(type(0.2e-1)) print(type(7.8263692594256e-06)) 以上代码执行结果都是：number 4、string（字符串） 字符串由一对双引号或单引号来表示。 string1 = \"this is string1\" string2 = 'this is string2' 字符串块 也可以用 2 个方括号 [[ ]] 来表示\"一块\"字符串。 html = [[ 程序喵 ]] print(html) 以下代码执行结果为： 程序喵 字符串算术运算 在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字，这点区分于java之类语言。 print(\"2\" + 6) --> 8.0 print(\"2\" + \"6\") --> 8.0 print(\"2 + 6\") --> 2 + 6 print(\"-2e2\" * \"6\") --> -1200.0 print(\"error\" + 1) --> input:5: attempt to perform arithmetic on a string value 字符串拼接 字符串连接使用的是 .. ，如： print(\"a\" .. 'b') --> ab print(157 .. 428) --> 157428 字符串长度 使用 # 来计算字符串的长度，放在字符串前面。 汉字占用 3 个字符长度 表情符号占用 4 个字符长度。 如下实例： len = \"www.ibloger.net\" print(#len) --> 15 print(#\"喵\") --> 3 print(#\"程序喵\") --> 9 print(#\"🐱\") --> 4 5、table（表） 在 Lua 里 table 的创建是通过\"构造表达式\"来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表。 -- 创建一个空的 table local tbl1 = {} -- 直接初始表 local tbl2 = {\"apple\", \"pear\", \"orange\", \"grape\"} Lua 中的表（table）其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字或者是字符串。 a = {} a[\"k\"] = \"v\" key = 10 a[key] = 22 a[key] = a[key] + 11 for k, v in pairs(a) do print(k .. \" : \" .. v) end 脚本执行结果为： k : v 10 : 33 不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引是以 1 开始。 local tbl = {\"apple\", \"pear\", \"orange\", \"grape\"} for key, val in pairs(tbl) do print(\"Key\", key) end 脚本执行结果为： Key 1 Key 2 Key 3 Key 4 table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。 索引 Lua 对 table 的索引使用方括号 []。也提供了 . 操作。 t[i] t.i -- 当索引为字符串类型时的一种简化写法 例如： site = {} site[\"key\"] = \"www.ibloger.net\" print(site[\"key\"]) --> www.ibloger.net print(site.key) --> www.ibloger.net 6、function（函数） 在 Lua 中，函数是被看作是\"第一类值（First-Class Value）\"，函数可以存在变量里。 function factorial1(n) if n == 0 then return 1 else return n * factorial1(n - 1) end end print(factorial1(5)) --> 120 factorial2 = factorial1 print(factorial2(5)) --> 120 function 可以以匿名函数（anonymous function）的方式通过参数传递。 function anonymous(tab, fun) for k, v in pairs(tab) do print(fun(k, v)) end end tab = { key1 = \"val1\", key2 = \"val2\" } anonymous(tab, function(key, val) -- function 匿名函数 return key .. \" = \" .. val end) 脚本执行结果为： key1 = val1 key2 = val2 7、thread（线程） 在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。 线程跟协程的区别 线程可以同时多个运行 协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。 8、userdata（自定义类型） userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。 powered by Gitbook该文件修订时间： 2019-04-16 15:45:18 "},"base/Lua变量.html":{"url":"base/Lua变量.html","title":"Lua 变量","keywords":"","body":"Lua 变量 变量在使用前，必须在代码中进行声明，即创建该变量。编译程序执行代码之前编译器需要知道如何给语句变量开辟存储区，用于存储变量的值。 一、变量类型 Lua 变量有三种类型：全局变量、局部变量、表中的域。 函数外的变量默认为全局变量，除非用 local 显示声明。 局部变量的作用域为从声明位置开始到所在语句块结束（或者是直到下一个同名局部变量的声明）。 变量的默认值均为 nil。 如下示例 a = 5 -- 全局变量 local b = 5 -- 局部变量 function joke() c = 5 -- 全局变量 local d = 6 -- 局部变量 end joke() print(c, d) --> 5 nil do local a = 6 -- 局部变量 b = 8 -- 全局变量 print(a, b); --> 6 8 end print(a, b) --> 5 8 二、赋值语句 赋值是改变一个变量的值和改变表域的最基本的方法。 a = \"hello\" .. \"world\" t.n = t.n + 1 Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。 a, b = 10, 2*x --> a=10; b=2*x 遇到赋值语句 Lua 会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值： x, y = y, x -- swap 'x' for 'y' a[i], a[j] = a[j], a[i] -- swap 'a[i]' for 'a[j]' 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略： 变量个数 > 值的个数：按变量个数补足nil 变量个数 ：多余的值会被忽略 例如： a, b, c = 0, 1 print(a,b,c) --> 0 1 nil a, b = a+1, b+1, b+2 -- value of b+2 is ignored print(a,b) --> 1 2 a, b, c = 0 print(a,b,c) --> 0 nil nil 上面最后一个例子是一个常见的错误情况，注意：如果要对多个变量赋值必须依次对每个变量赋值。 a, b, c = 0, 0, 0 print(a,b,c) --> 0 0 0 多值赋值经常用来交换变量，或将函数调用返回给变量： a, b = f() f() 返回两个值，第一个赋给a，第二个赋给b。 应该尽可能的使用局部变量，有两个好处： 避免命名冲突。 访问局部变量的速度比全局变量更快。 powered by Gitbook该文件修订时间： 2019-04-16 14:29:13 "},"base/Lua循环.html":{"url":"base/Lua循环.html","title":"Lua 循环","keywords":"","body":"Lua 循环 很多情况下我们需要做一些有规律性的重复操作，因此在程序中就需要重复执行某些语句。 一组被重复执行的语句称之为循环体，能否继续重复，决定循环的终止条件。 循环结构是在一定条件下反复执行某段程序的流程结构，被反复执行的程序被称为循环体。 循环语句是由循环体及循环的终止条件两部分组成的。 一、循环方式 Lua 提供了以下几种循环处理方式： 循环类型 描述 while 循环 在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true for 循环 重复执行指定语句，重复次数可在 for 语句中控制。 Lua repeat...until 重复执行循环，直到 指定的条件为真时为止 循环嵌套 可以在循环内嵌套一个或多个循环语句（while、for、do..while） 循环控制 循环控制语句用于控制程序的流程，以实现程序的各种结构方式。 控制语句 描述 break 语句 退出当前循环或语句，并开始脚本执行紧接着的语句。 流程图如下 另外：Lua 并没有提供类似 contrnue 的语句。 二、循环类型介绍 1、while 循环 Lua 编程语言中 while 循环语句在判断条件为 true 时会重复执行循环体语句。 语法 while(condition) do statements end statements（循环体语句）可以是一条或多条语句，condition(条件) 可以是任意表达式，在 condition(条件) 为 true 时执行循环体语句。 流程图如下： 在以上流程图中我们可以看出在 condition(条件)为 false 时会跳过当前循环并开始脚本执行紧接着的语句。 实例 以下实例循环输出 a 的值： a=10 while(a 执行以上代码，输出结果如下： a 的值为: 10 a 的值为: 11 a 的值为: 12 2、for 循环 Lua for 循环是一种重复控制结构，用于有效地编写需要执行特定次数的循环。 其中 for 语句有：数值循环、泛型循环 两种类型。 数值for循环 语法格式 for var=exp1, exp2, exp3 do end var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次\"执行体\"。exp3 是可选的，如果不指定，默认为1。 for i=1, 6 do print(i) --> 依次打印：1到6 end for i=10, 1, -1 do print(i) --> 依次打印：10到1 end 三个表达式在循环开始前一次性求值，以后不再进行求值。比如下面的 f(x) 只会在循环开始前执行一次，其结果用在后面的循环中。 function f(x) print(\"function\") return x*2 end for i=1, f(3) do print(i) end 结果如下 function 1 2 3 4 5 6 可以看到 函数 f(x) 只在循环开始前执行一次。 泛型for循环 泛型for循环通过一个迭代器函数来遍历所有值，类似java中的 foreach 语句。语法格式如下。 --打印数组a的所有值 for i, v in ipairs(a) do print(v) end i 是数组索引值 v 是对应索引的数组元素值。 ipairs 是Lua提供的一个迭代器函数，用来迭代数组。 实例如下 days = {\"Suanday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"} for i, v in ipairs(days) do print(i, v) end 以上实例输出结果为： 1 Suanday 2 Monday 3 Tuesday 4 Wednesday 5 Thursday 6 Friday 7 Saturday 3、repeat...until 循环 repeat...until 循环保证至少执行一次，循环在底部检查循环的条件。类似于java中的 do..while 循环。 语法如下 repeat statement(s) until( condition ) statements (循环体语句)：可以是一条或多条语句 condition (条件)：可以是任意表达式，条件为 true 时执行循环体语句，为 false 时会跳过当前循环。 循环流程图如下： 示例代码 a = 10 repeat print(\"value of a:\", a) a = a + 1 until( a > 13 ) 执行结果 value of a: 10 value of a: 11 value of a: 12 value of a: 13 4、循环嵌套 Lua 编程语言中允许循环中嵌入循环。以下实例演示了 Lua 循环嵌套的应用。 for 循环嵌套语法格式 for init, max/min value, increment do for init, max/min value, increment do statements end statements end while 循环嵌套语法格式: while(condition) do while(condition) do statement(s) end statement(s) end repeat...until 循环嵌套语法格式: repeat statements repeat statements until(condition) until(condition) 除了以上同类型循环嵌套外，我们还可以使用不同的循环类型来嵌套，如 for 循环体中嵌套 while 循环。 j = 2 for i=2,10 do for j=2,(i/j) , 2 do if(not(i%j)) then break end if(j > (i/j)) then print(\"i 的值为：\",i) end end end 运行结果 i 的值为： 8 i 的值为： 9 i 的值为： 10 powered by Gitbook该文件修订时间： 2019-04-16 15:40:17 "},"base/Lua运算符.html":{"url":"base/Lua运算符.html","title":"Lua 运算符","keywords":"","body":"Lua 运算符 运算符是告诉解释器执行特定数学或逻辑操作的符号。 Lua语言内置运算符丰富，并提供以下类型的运算符。 算术运算符 关系运算符 逻辑运算符 其它运算符 一、算术运算符 下表列出了 Lua 语言中的常用算术运算符，设定 A 的值为10，B 的值为 20。 操作符 描述 实例 + 加法 A + B = 30 - 减法 A - B = -10 * 乘法 A * B = 200 / 除法 B / A = 2 % 取余 B % A = 0 ^ 乘幂 A^2 = 100 - 负号 -A = -10 二、关系运算符 下表列出了 Lua 语言中的常用关系运算符，设定 A 的值为10，B 的值为 20。 操作符 描述 实例 == 等于，检测两个值是否相等，相等返回 true，否则返回 false (A == B) 为 false。 ~= 不等于，检测两个值是否相等，相等返回 false，否则返回 true (A ~= B) 为 true。 > 大于，如果左边的值大于右边的值，返回 true，否则返回 false (A > B) 为 false。 小于，如果左边的值大于右边的值，返回 false，否则返回 true (A >= 大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false (A >= B) is not true. 小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false (A 三、逻辑运算符 下表列出了 Lua 语言中的常用逻辑运算符，设定 A 的值为 true，B 的值为 false。 操作符 描述 实例 and 逻辑与操作符。 如果两边的操作都为 true 则条件为 true。 (A and B) 为 false。 or 逻辑或操作符。 如果两边的操作任一一个为 true 则条件为 true。 (A or B) 为 true。 not 逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。 not(A and B) 为 true。 四、其他运算符 下表列出了 Lua 语言中的连接运算符与计算表或字符串长度的运算符： 操作符 描述 实例 .. 连接两个字符串 a..b ，其中 a 为 \"Hello \"，b 为 \"World\", 输出结果为 \"Hello World\"。 # 一元运算符，返回字符串或表的长度。 #\"Hello\" 返回 5 五、运算符优先级 从高到低的顺序： ^ not - (unary) * / + - .. = ~= == and or 除了 ^ 和 .. 外所有的二元运算符都是左连接的。 a+i (a+i) 5+((x^2)*8) a (a -(x^2) x^y^z --> x^(y^z) 示例 a = 20 b = 10 c = 15 d = 5 e = (a + b) * c / d; -- (30 * 15) / 5 print(\"(a + b) * c / d 运算值为 :\", e) e = ((a + b) * c) / d; -- (30 * 15) / 5 print(\"((a + b) * c) / d 运算值为 :\", e) e = (a + b) * (c / d); -- (30) * (15/5) print(\"(a + b) * (c / d) 运算值为 :\", e) e = a + (b * c) / d; -- 20 + (150/5) print(\"a + (b * c) / d 运算值为 :\", e) powered by Gitbook该文件修订时间： 2019-04-16 16:48:41 "},"base/Lua流程控制.html":{"url":"base/Lua流程控制.html","title":"Lua 流程控制","keywords":"","body":"Lua 流程控制 Lua 编程语言流程控制语句通过程序设定一个或多个条件语句来设定。在条件为 true 时执行指定程序代码，在条件为 false 时执行其他指定代码。 控制结构的条件表达式结果可以是任何值，其中 false 和 nil 为假，true 和 非nil 都为真，包括 0 和负数。 --[ 0 为 true ] if(0) then print(\"0 为 true\") end if(1) then print(\"1 为 true\") end if(-1) then print(\"-1 为 true\") end 输出结果为： 0 为 true 1 为 true -1 为 true 一、if 语句 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。 语法格式如下： if(布尔表达式) then --[ 在布尔表达式为 true 时执行的语句 --] ends 流程图如下 如下示例： a = 10; if(a 二、if...else 语句 if 语句可以与 else 语句搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码块。 语法格式如下： if(布尔表达式) then --[ 布尔表达式为 true 时执行该语句块 --] else --[ 布尔表达式为 false 时执行该语句块 --] end 流程图如下 如下示例： a = 100; if(a 三、if...else if...else 语句 在 if 条件表达式为 false 时执行 else if...else 语句代码块，用于检测多个条件语句。 语法格式： if(布尔表达式 1) then --[ 在布尔表达式 1 为 true 时执行该语句块 --] elseif(布尔表达式 2) --[ 在布尔表达式 2 为 true 时执行该语句块 --] elseif(布尔表达式 3) --[ 在布尔表达式 3 为 true 时执行该语句块 --] else --[ 如果以上布尔表达式都不为 true 则执行该语句块 --] end 如下示例： a = 100 if(a == 10) then print(\"a 的值为 10\" ) elseif( a == 20 ) then print(\"a 的值为 20\" ) elseif( a == 30 ) then print(\"a 的值为 30\" ) else print(\"没有匹配 a 的值\" ) end print(\"a 的真实值为: \", a) 执行结果： 没有匹配 a 的值 a 的真实值为: 100 powered by Gitbook该文件修订时间： 2019-04-25 19:42:26 "},"base/Lua函数.html":{"url":"base/Lua函数.html","title":"Lua 函数","keywords":"","body":"Lua 函数 函数是对语句和表达式进行抽象的主要方法。既可以用来处理一些特殊的工作，也可以用来计算一些值。 Lua 提供了许多的内建函数，你可以很方便的在程序中调用它们，如 print() 函数可以将传入的参数打印在控制台上。 Lua 函数主要有两种用途： 完成指定的任务，这种情况下函数作为调用语句使用； 计算并返回值，这种情况下函数作为赋值语句的表达式使用。 一、函数定义 格式如下： optional_function_scope function function_name(argument1, argument2, argument3..., argumentn) function_body return result_params_comma_separated end optional_function_scope：该参数是可选的制定函数是全局函数还是局部函数，未设置该参数末尾为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。 function_name：指定函数名称。 argument1, argument2, argument3..., argumentn：函数参数，多个参数以逗号隔开，函数也可以不带参数。 function_body：函数体，函数中需要执行的代码语句块。 result_params_comma_separated：函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。 以下是 max() 函数的源代码。 此函数接受两个参数num1和num2，并返回两者的最大值 --[[ 函数返回两个值的最大值 --]] function max(num1, num2) if (num1 > num2) then result = num1; else result = num2; end return result; end -- 调用函数 print(\"两值比较最大值为 \",max(10, 4)) print(\"两值比较最大值为 \",max(5, 6)) 二、传递函数 在Lua中，将函数赋值给变量，也可以将它们作为另一个函数的参数传递。 下面是一个简单的例子，实现在Lua中分配和传递函数作为参数。 myprint = function(param) print(\"这是打印函数 - ##\", param, \"##\") end function add(num1, num2, functionPrint) result = num1 + num2 -- 调用传递的函数参数 functionPrint(result) end myprint(10) -- myprint 函数作为参数传递 add(2, 5, myprint) 以上代码执行结果为： 这是打印函数 - ## 10 ## 这是打印函数 - ## 7 ## 三、可变参数的函数 使用 ... 作为参数在Lua中创建具有可变参数的函数。 下面是通过函数计算返回平均值，并采用变量参数的示例。 function average(...) result = 0 local arg={...} for i,v in ipairs(arg) do result = result + v end print(\"总共传入 \" .. #arg .. \" 个数\") return result/#arg end print(\"平均值为\",average(10,5,3,4,5,6)) 运行结果： 总共传入 6 个数 平均值为 5.5 四、多返回值 Lua 函数可以返回多个结果值，比如自带的 string.find，其返回匹配串\"开始和结束的下标\"（如果不存在匹配串返回 nil）。 s, e = string.find(\"www.ibloger.net\", \"ibloger\") print(s, e) --> 5 11 Lua 函数中，在 return 后列出要返回的值得列表即可返回多值，如： function maximum (a) local mi = 1 -- 最大值索引 local m = a[mi] -- 最大值 for i,val in ipairs(a) do if val > m then mi = i m = val end end return m, mi end print(maximum({8, 10, 23, 12, 5})) --> 23 3 powered by Gitbook该文件修订时间： 2019-04-16 19:41:59 "},"base/Lua字符串.html":{"url":"base/Lua字符串.html","title":"Lua 字符串","keywords":"","body":"Lua 字符串 字符串是由一系列字符以及控制字符组成，如换页符。 字符串可以用三种形式初始化，包括 单引号之间的字符 双引号之间的字符 [[ 和 ]]之间的字符 string1 = \"Lua\" print(\"\\\"String 1 is\\\"\", string1) string2 = '程序喵' print(\"String 2 is\", string2) string3 = [[\"Java 天下第一\"]] print(\"String 3 is\",string3) 当运行上面的程序时，将得到以下输出 \"String 1 is\" Lua String 2 is 程序喵 String 3 is \"Java 天下第一\" 转义字符用于表示不能直接显示的字符，比如后退键，回车键，等。如在字符串转换双引号可以使用 \"\\\"\"。 一、转义字符对应关系 转义字符 意义 ASCII码值（十进制） \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\\\ 代表一个反斜线字符''\\' 092 \\' 代表一个单引号（撇号）字符 039 \\\" 代表一个双引号字符 034 空字符(NULL) 000 \\ddd 1到3位八进制数所代表的任意字符 三位八进制 \\xhh 1到2位十六进制所代表的任意字符 二位十六进制 二、字符串操作 Lua 提供了很多的方法来支持字符串的操作： （1）string.upper(argument)：字符串全部大写字母。 print(string.upper(\"Java\")) --> JAVA （2）string.lower(argument)：字符串全部小写字母。 print(string.lower(\"Java\")) --> java （3）string.gsub(mainString, findString, replaceString, num)：字符串中替换 mainString：要替换的字符 findString：被替换的字符 replaceString：要替换的字符 num：替换次数（忽略则全部替换） 多返回值结果 print(string.gsub(\"aaaa\", \"a\", \"z\", 3)); --> zzza 3 （4）string.find(str, substr, [init, [end]])：字符搜索 在一个指定的目标字符串中搜索指定的内容(第三个参数为索引)，返回其具体位置。不存在则返回 nil。 print(string.find(\"Hello Lua user\", \"Lua\", 1)) --> （5）string.reverse(arg)：字符翻转 字符串反转 print(string.reverse(\"Java\")) --> avaJ （6）string.format(...)：格式化 一个类似 printf 的格式化字符串 print(string.format(\"the value is：%d\", 4)) --> the value is：4 print(string.format(\"字符串格式化 %s %s\", \"Hello \", \"World\")) --> 字符串格式化 Hello World print(string.format(\"%.4f\", 1/3)) --> 0.3333 date = 2; month = 1; year = 2019 print(string.format(\"日期格式化 %02d/%02d/%03d\", date, month, year)) --> 日期格式化 02/01/2019 （7）string.char(arg) 和 string.byte(arg[,int])：字符和字节表示 char 将整型数字转成字符并连接 byte 转换字符为整数值(可以指定某个字符，默认第一个字符) -- 转换第一个字符 print(string.byte(\"Lua\")) --> 76 -- 转换第三个字符 print(string.byte(\"Lua\", 3)) --> 97 -- 转换末尾第一个字符 print(string.byte(\"Lua\", -1)) --> 97 -- 第二个字符 print(string.byte(\"Lua\", 2)) --> 117 -- 转换末尾第二个字符 print(string.byte(\"Lua\", -2)) --> 117 -- 整数 ASCII 码转换为字符 print(string.char(97)) --> a print(string.char(97, 98, 99, 100)) --> abcd （8）string.len(arg)：字符串长度 计算字符串长度 一个字母、数字各占 1 个长度 一个汉字占 3 个长度 一个表情占 4 个字符print(string.len(\"chengxumiao\")) --> 11 print(string.len(\"程序喵\")) --> 9 print(string.len(\"🐱\")) --> 4 （9）string.rep(string, n)：字符串拷贝 返回字符串string的n个拷贝 print(string.rep(\"Java\", 3)) --> JavaJavaJava （10）.. ：字符串拼接 print(\"www.ibloger\" .. \".net\") --> www.ibloger.net print(\"程\"..\"序\"..\"喵\"..\"🐱\") --> 程序喵🐱 powered by Gitbook该文件修订时间： 2019-04-16 20:38:39 "},"base/Lua数组.html":{"url":"base/Lua数组.html","title":"Lua 数组","keywords":"","body":"Lua 数组 数组，就是相同数据类型的元素按一定顺序排列的集合，可以是一维数组和多维数组。 Lua 数组的索引键值可以使用整数表示，数组的大小不是固定的。 一、一维数组 一维数组是最简单的数组，其逻辑结构是线性表。一维数组可以用for循环出数组中的元素， 如下示例： array = {\"Lua\", \"Tutorial\"} for i= 0, 2 do print(array[i]) end 以上代码执行输出结果为： nil Lua Tutorial 在 Lua 索引值是以 1 为起始，但你也可以指定 0 开始。如果知道的索引没有值则返回 nil。 除此外我们还可以以负数为数组索引值： 如下示例 array = {} for i= -2, 2 do array[i] = i *2 end for i = -2,2 do print(array[i]) end 以上代码执行输出结果为： -4 -2 0 2 4 二、多维数组 多维数组即数组中包含数组或一维数组的索引键对应一个数组。 以下是一个三行三列的阵列多维数组： array = {} for i=1, 3 do array[i] = {} for j=1, 3 do array[i][j] = i*j end end -- 访问数组 for i=1,3 do for j=1,3 do print('i：'..i, 'j:'..j, '= '..array[i][j]) end end 以上代码执行输出结果为： i：1 j:1 = 1 i：1 j:2 = 2 i：1 j:3 = 3 i：2 j:1 = 2 i：2 j:2 = 4 i：2 j:3 = 6 i：3 j:1 = 3 i：3 j:2 = 6 i：3 j:3 = 9 不同索引键的三行三列阵列多维数组。如下示例 -- 初始化数组 array = {} maxRows = 3 maxColumns = 3 for row=1,maxRows do for col=1,maxColumns do array[row*maxColumns +col] = row*col end end -- 访问数组 for row=1,maxRows do for col=1,maxColumns do print(array[row*maxColumns +col]) end end 以上代码执行输出结果为： 1 2 3 2 4 6 3 6 9 如在上面的示例中所看到的，数据是基于索引存储的。可以以稀疏的方式放置元素，这是Lua实现数组的方式。 powered by Gitbook该文件修订时间： 2019-04-16 20:58:08 "},"base/Lua迭代器.html":{"url":"base/Lua迭代器.html","title":"Lua 迭代器","keywords":"","body":"Lua 迭代器 迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址. 在Lua中迭代器是一种支持指针类型的结构，它可以遍历集合的每一个元素。 一、语法 泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。 泛型 for 迭代器提供了集合的 key/value 对，语法格式如下： for k, v in pairs(t) do print(k, v) end k：键值对的key v：键值对的Value pairs(t)：为表达式列表。 查看以下实例: array = {\"Lua\", \"Tutorial\"} for key,value in ipairs(array) do print(key, value) end 以上代码执行输出结果为： 1 Lua 2 Tutorial 以上实例中使用了 Lua 默认提供的迭代函数 ipairs。 二、执行过程 泛型 for 的执行过程 首先，初始化，计算 in 后面表达式的值，表达式应该返回范性for需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用nil补足，多出部分会被忽略。 第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于for结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。 第三，将迭代函数返回的值赋给变量列表。 第四，如果返回的第一个值为nil循环结束，否则执行循环体。 第五，回到第二步再次调用迭代函数。 在 Lua 中我们常常使用函数来描述迭代器，每次调用该函数就返回集合的下一个元素。 Lua 的迭代器包含以下两种类型：无状态的迭代器、有状态的迭代器。 无状态的迭代器 无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。 每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。 这种无状态迭代器的典型的简单的例子是 ipairs，他遍历数组的每一个元素。 以下实例使用了一个简单的函数来实现迭代器，实现数字 n 的平方： function square(iteratorMaxCount, currentNumber)s if(currentNumber 以上实例输出结果为： 1 1 2 4 3 9 稍微修改上面的代码，以模仿迭代器的ipairs函数的工作方式。输出结果相同。 function square(iteratorMaxCount, currentNumber) if(currentNumber 多状态的迭代器 上面使用函数的迭代示例不保留状态。每次调用该函数时，它都会根据发送给函数的第二个变量返回集合的下一个元素。 要保持当前元素的状态，可使用闭包(Closure)。闭包在函数调用中保留变量值。要创建一个新的闭包，这里首先创建两个函数，包括闭包本身和一个工厂，即创建闭包的函数。 如下是一个创建迭代器的例子，并将使用闭包。 array = {\"Java\", \"JavaScript\"} function elementIterator(collection) local index = 0 local count = #collection -- 闭包函数 return function () index = index + 1 if index 输出结果： Java JavaScript 以上实例中我们可以看到，elementIterator 内使用了闭包函数，实现计算集合大小并输出各个元素。 powered by Gitbook该文件修订时间： 2019-04-17 14:34:48 "},"base/Lua表table.html":{"url":"base/Lua表table.html","title":"Lua table 表","keywords":"","body":"Lua 表 table table 是 Lua 的一种数据结构，用来帮助我们创建不同的数据类型，如：数字、字典等。 table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。 table 是不固定大小的，你可以根据自己需要进行扩容。 table 可以解决模块（module）、包（package）和对象（Object）的表示。例如 string.format 表示使用 format 来索引 table string。 一、table(表)的构造 构造器是创建和初始化表的表达式。表是 Lua 特有的功能强大的东西。最简单的构造函数是 {}，用来创建一个空表。可以直接初始化数组。 -- 初始化表 mytable = {} -- 指定值 mytable[1]= \"Lua\" -- 移除引用 mytable = nil -- lua 垃圾回收会释放内存 当我们为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b 都指向同一个内存。如果 a 设置为 nil，则 b 同样能访问 table 的元素。当没有对表的引用时，Lua的垃圾回收机制会清理相对应的内存。 -- 简单的 table mytable = {} print(\"mytable 的类型是 \",type(mytable)) --> mytable 的类型是 table mytable[1]= \"Lua\" mytable[\"wow\"] = \"修改前\" print(\"mytable 索引为 1 的元素是 \", mytable[1]) --> mytable 索引为 1 的元素是 Lua print(\"mytable 索引为 wow 的元素是 \", mytable[\"wow\"]) --> mytable 索引为 wow 的元素是 修改前 -- alternatetable和mytable的是指同一个 table alternatetable = mytable print(\"alternatetable 索引为 1 的元素是 \", alternatetable[1]) --> mytable 索引为 1 的元素是 Lua print(\"mytable 索引为 wow 的元素是 \", alternatetable[\"wow\"]) --> mytable 索引为 wow 的元素是 修改前 alternatetable[\"wow\"] = \"修改后\" print(\"mytable 索引为 wow 的元素是 \", mytable[\"wow\"]) --> mytable 索引为 wow 的元素是 修改后 -- 释放变量 alternatetable = nil print(\"alternatetable 是 \", alternatetable) --> alternatetable 是 nil -- mytable 仍然可以访问 print(\"mytable 索引为 wow 的元素是 \", mytable[\"wow\"]) --> mytable 索引为 wow 的元素是 修改后 mytable = nil print(\"mytable 是 \", mytable) --> mytable 是 nil 二、Table 操作 （1）table.concat (table [, step [, start [, end]]])：连接 根据给定的参数连接表中的字符串，table.concat() 列出参数中指定 table 数组部分从 start 位置到 end 位置的所有元素，元素间以指定的分隔符 step 隔开。 fruits = {\"banana\",\"orange\",\"apple\"} -- 返回 table 连接后的字符串 print(\"连接后的字符串 \",table.concat(fruits)) --> 连接后的字符串 bananaorangeapple -- 指定连接字符 print(\"连接后的字符串 \",table.concat(fruits,\", \")) --> 连接后的字符串 banana, orange, apple -- 指定索引来连接 table print(\"连接后的字符串 \",table.concat(fruits,\", \", 2,3)) --> 连接后的字符串 orange, apple （2）table.insert (table, [pos,] value)：插入 在 table 的数组部分指定位置 pos 插入一个值为 value 的元素，pos 参数可选, 默认为数组部分末尾。 fruits = {\"banana\",\"orange\",\"apple\"} -- 在末尾插入 table.insert(fruits, \"mango\") print(\"索引为 4 的元素为 \",fruits[4]) --> 索引为 4 的元素为 mango -- 在索引为 2 的键处插入 table.insert(fruits,2, \"grapes\") print(\"索引为 2 的元素为 \", fruits[2]) --> 索引为 2 的元素为 grapes print(\"最后一个元素为 \", fruits[5]) --> 最后一个元素为 mango -- 在末尾移除 table.remove(fruits) print(\"移除后最后一个元素为 \", fruits[5]) （3）table.maxn (table)：最大key值 指定 table 中所有正数 key 值中最大的 key 值，如果不存在 key 值为正数的元素, 则返回 0。 Lua5.2 之后该方法已经不存在了，本文使用了自定义函数实现 function table_maxn(t) local mn = 0 for k, v in pairs(t) do if mn tbl 长度 3 print(\"tbl 最大值 \", table_maxn(tbl)) --> tbl 最大值 26 （4）table.remove (table [, pos])：移除 返回 table 数组部分位于 pos 位置的元素，其后的元素会被前移，pos参数可选, 默认为 table 长度, 即从最后一个元素删起。 （5）table.sort (table [, comp])：排序 根据可选的比较器参数 comp 对表进行升序排序。 fruits = {\"banana\",\"orange\",\"apple\",\"grapes\"} for k,v in ipairs(fruits) do print(k,v) end table.sort(fruits) print(\"排序\") for k,v in ipairs(fruits) do print(k,v) end powered by Gitbook该文件修订时间： 2019-04-17 15:29:59 "},"base/Lua模块与包.html":{"url":"base/Lua模块与包.html","title":"Lua 模块与包","keywords":"","body":"Lua 模块与包 模块类似于一个封装库，从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。 一、模块 Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。 以下为创建自定义模块 module.lua，文件代码格式如下： -- 文件名为 module.lua -- 定义一个名为 module 的模块 module = {} -- 定义一个常量 module.constant = \"这是一个常量\" -- 定义一个函数 function module.func1() io.write(\"这是一个公有函数！\\n\") end local function func2() print(\"这是一个私有函数！\") end function module.func3() func2() end return module 由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。 上面的 func2 声明为程序块的局部变量，即表示一个私有函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的公有函数来调。 二、require 函数 Lua 提供了一个名为 require 的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。例如： require(\"\") -- 或者 require \"\" 执行 require 后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。 -- module 模块为上文提到到 module.lua require(\"module\") print(module.constant) --> 这是一个常量 module.func1() --> 这是一个公有函数！ module.func3() --> 这是一个私有函数！ 注意： （1）将运行的模块和文件放在同一目录中。（2）模块名称及其文件名相同。 或者可以给加载的模块定义一个局部的别名变量。 -- 别名变量 m local m = require(\"module\") print(m.constant) --> 这是一个常量 m.func1() --> 这是一个公有函数！ m.func3() --> 这是一个私有函数！ 还可以为个别函数设置不同的名称。 local m = require(\"module\") local f = m.func1 print(m.constant) --> 这是一个常量 f() --> 这是一个公有函数！ m.func3() --> 这是一个私有函数！ powered by Gitbook该文件修订时间： 2019-04-17 16:30:13 "},"base/Lua元表.html":{"url":"base/Lua元表.html","title":"Lua 元表","keywords":"","body":"Lua 元表（Metatable） 在 Lua table 中我们可以访问对应的 key 来得到 value 值，但是却无法对两个 table 进行操作。 因此 Lua 提供了元表（Metatable），允许我们改变 table 的行为，每个行为关联了对应的元方法（MetaMethod）。 例如：使用元表可以定义计算两个 table 的相加操作。先检查两者之一是否有元表，之后检查是否有一个叫 __add 的元方法，若找到，则调用对应的值。 一、设置与获取 有两个很重要的函数来处理元表： setmetatable(table, metatable)：为表设置元表。 getmetatable(table)：获取表的元表。 如下示例：对指定的表设置元表。 mytable = {} -- 普通表 mymetatable = {} -- 元表 setmetatable(mytable, mymetatable) -- 把 mymetatable 设为 mytable 的元表 等同于 mytable = setmetatable({},{}) 如下示例：返回对象元表。 getmetatable(mytable) -- 返回 mymetatable 二、__index 元方法 这是 metatable 最常用的键。 当你通过键来访问 table 的时候，如果这个键有值就直接返回；如果没有值，那么 Lua 就会寻找该 table 的 metatable，假定 metatable 中有 __index 键。如果 __index 包含一个表格，Lua 会在表格中查找相应的键。 我们可以在使用 lua 命令进入交互模式查看： Lua 5.3.5 Copyright (C) 1994-2018 Lua.org, PUC-Rio > other = {foo=3} > t = setmetatable({}, {__index = other}) > t.foo 3 > t.abc nil > 如果 __index 包含一个函数的话，Lua 就会调用那个函数，table 和键会作为参数传递给函数。 __index 元方法查看表中元素是否存在，如果不存在，返回结果为 nil；如果存在则由 __index 返回结果。 mytable = setmetatable({key1 = \"value1\"}, { __index = function(mytable, key) if key == \"key2\" then return \"metatablevalue\" else return nil end end }) print(mytable.key1, mytable.key2) --> value1 metatablevalue 解析： mytable 表赋值为 {key1 = \"value1\"}。 mytable 设置了元表，元方法为 __index。 在 mytable 表中查找 key1，如果找到，返回该元素，找不到则继续。 在 mytable 表中查找 key2，如果找到，返回该元素，找不到则继续。 判断元表有没有 __index 方法，如果 __index 方法是一个函数，则调用该函数。 元方法中查看是否传入 key2 键的参数（示例中 mytable.key2 已设置），如果传入 key2 参数返回 metatablevalue，否则返回 mytable 对应的键值。 以上代码可以简化为： mytable = setmetatable({key1 = \"value1\"}, { __index = {key2 = \"metatablevalue\"} }) print(mytable.key1, mytable.key2) 三、__newindex 元方法 __newindex 元方法用来对表更新，__index 则用来对表访问 。 当将 __newindex 添加到 metatable 时，如果表中没有键，则新键的行为将由元方法定义。 当你给表的一个缺少的索引赋值，解释器就会查找 __newindex 元方法：如果存在则调用这个函数而不进行赋值操作。 如下示例：当主表中没有索引时设置 metatable 索引。 mymetatable = {} mytable = setmetatable({key1 = \"value1\"}, { __newindex = mymetatable }) print(mytable.key1) --> value1 mytable.newkey = \"新值2\" print(mytable.newkey, mymetatable.newkey) --> nil 新值2 mytable.key1 = \"新值1\" print(mytable.key1, mymetatable.newkey1) --> 新值1 nil 以上实例中表设置了元方法 __newindex，在对新索引键（newkey）赋值时（mytable.newkey = \"新值2\"），会调用元方法，而不进行赋值。而如果对已存在的索引键（key1），则会进行赋值，而不调用元方法 __newindex。 rawset 函数 以下实例使用了 rawset 函数来更新表： mytable = setmetatable({key1 = \"value1\"}, { __newindex = function(mytable, key, value) print(key, value) rawset(mytable, key, \"\\\"\"..value..\"\\\"\") end }) mytable.key1 = \"new value\" mytable.key2 = 4 mytable.key3 = 'abc' print(mytable.key1, mytable.key2, mytable.key3) 执行结果 key2 4 key3 abc new value \"4\" \"abc\" rawset 设置值而不使用元表的 __newindex。 类似地，有一个 rawget 可以在不使用 __index 的情况下获取值。 四、元素添加操作符 以下实例演示了两表相加操作： -- 两表相加操作 mytable = setmetatable({ 1, 2, 3 }, { __add = function(mytable, newtable) for i = 1, #(newtable) do table.insert(mytable, #(mytable)+1, newtable[i]) -- 插入 end return mytable end }) secondtable = {4, 5, 6} mytable = mytable + secondtable for k,v in ipairs(mytable) do print(k,v) end 执行结果 1 1 2 2 3 3 4 4 5 5 6 6 __add 是元方法（MetaMethod），这是 Lua 内建约定的，其它的还有如下的 MetaMethod 模式 描述 __add(a, b) 对应表达式 a + b __sub(a, b) 对应表达式 a - b __mul(a, b) 对应表达式 a * b __div(a, b) 对应表达式 a / b __mod(a, b) 对应表达式 a % b __pow(a, b) 对应表达式 a ^ b __unm(a) 对应表达式 -a __concat(a, b) 对应表达式 a .. b __len(a) 对应表达式 #a __eq(a, b) 对应表达式 a == b __lt(a, b) 对应表达式 a __le(a, b) 对应表达式 a __index(a, b) 对应表达式 a.b __newindex(a, b, c) 对应表达式 a.b = c __call(a, ...) 对应表达式 a(...) __call 元方法 __call 元方法在 Lua 调用一个值时调用。 以下实例演示了计算表中元素的和： mytable = setmetatable({10}, { __call = function(mytable, newtable) sum = 0 for i = 1, #(mytable) do sum = sum + mytable[i] end for i = 1, #(newtable) do sum = sum + newtable[i] end return sum end }) newtable = {10,20,30} print(mytable(newtable)) --> 70 __tostring 元方法 __tostring 元方法用于修改表的输出行为。以下实例我们自定义了表的输出内容： mytable = setmetatable({ 10, 20, 30 }, { __tostring = function(mytable) sum = 0 for k, v in pairs(mytable) do sum = sum + v end return \"表所有元素的和为 \" .. sum end }) print(mytable) --> 表所有元素的和为 60 从本文中我们可以知道元表可以很好的简化我们的代码功能，所以了解 Lua 的元表，可以让我们写出更加简单优秀的 Lua 代码。 powered by Gitbook该文件修订时间： 2019-04-17 19:04:00 "},"base/Lua协同程序.html":{"url":"base/Lua协同程序.html","title":"Lua 协同程序","keywords":"","body":"Lua 协同程序 coroutine 一、协同 (coroutine) 协同程序 与 线程 比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。 协同是非常强大的功能，但是用起来也很复杂。 线程和协同程序区别 一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。 在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。 协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。 二、方法 方法 作用描述 coroutine.create(f) 使用函数 f 创建一个新的协同程序，并返回 thread 类型的对象。 coroutine.resume(co [, val1, ...]) 恢复（重启）协程 co 并传递参数(如果有的话)。它返回操作状态和可选的其他返回值。 coroutine.running() 返回正在跑的coroutine，当使用 running 的时候，就是返回一个corouting的线程号。 coroutine.status(co) 查看coroutine的状态，有 dead，suspend，running 三种。 coroutine.wrap(f) 与 create 一样，coroutine.wrap 函数会创建一个协同程序，但它不会返回协同程序本身，而是返回一个函数，当调用它时，它会恢复协同程序。 coroutine.yield(...) 挂起coroutine，暂停正在运行的协同程序。传递给此方法的参数充当 resume 函数的附加返回值。 三、示例 示例1 -- coroutine_test.lua 文件 co = coroutine.create(function(i) print(i); end) coroutine.resume(co, 1) --> 1 print(coroutine.status(co)) --> dead（死亡） print(\"----------\") co = coroutine.wrap(function(i) print(i); end) -- 函数调用 co(10) --> 10 print(\"----------\") co2 = coroutine.create(function() for i=1,10 do print(i) if i == 3 then print(coroutine.status(co2)) --> running（运行） print(coroutine.running()) --> thread: xxxxxx false end coroutine.yield() end end) coroutine.resume(co2) --> 1 coroutine.resume(co2) --> 2 coroutine.resume(co2) --> 3 print(coroutine.status(co2)) --> suspended（挂起） print(coroutine.running()) --> thread: xxxxxx true print(\"----------\") 执行结果 1 dead ---------- 10 ---------- 1 2 3 running thread: 0x1c49fd8 false suspended thread: 0x1c3d018 true ---------- 如果将 coroutine.yield() 一行注释掉，执行结果如下 1 dead ---------- 10 ---------- 1 2 3 running thread: 0x7fe6f1505258 false 4 5 6 7 8 9 10 dead thread: 0x7fe6f2000008 true ---------- coroutine.running 就可以看出来 coroutine 在底层实现就是一个线程。 当 create 一个 coroutine 的时候就是在新线程中注册了一个事件。 当使用 resume 触发事件的时候，create 的 coroutine 函数就被执行了 当遇到 yield 的时候就代表挂起当前线程，等候再次 resume 触发事件。 示例2 接下来我们分析一个更详细的实例： function foo (a) print(\"foo 函数输出\", a) return coroutine.yield(2 * a) -- 返回 2*a 的值 end co = coroutine.create(function (a, b) print(\"第一次协同程序执行输出\", a, b) local r = foo(a + 1) print(\"第二次协同程序执行输出\", r) local r, s = coroutine.yield(a+b, a-b) -- a，b 的值为第一次调用协同程序时传入 print(\"第三次协同程序执行输出\", r, s) return b, \"结束协同程序\" -- b的值为第二次调用协同程序时传入 end) print(\"main\", coroutine.resume(co, 1, 10)) print() print(\"main\", coroutine.resume(co, \"r\")) print() print(\"main\", coroutine.resume(co, \"x\", \"y\")) print() print(\"main\", coroutine.resume(co, \"x\", \"y\")) 执行结果 第一次协同程序执行输出 1 10 foo 函数输出 2 main true 4 第二次协同程序执行输出 r main true 11 -9 第三次协同程序执行输出 x y main true 10 结束协同程序 main false cannot resume dead coroutine 分析 第一次 resume，将协同程序唤醒，resume 操作成功返回 true。 协同程序运行，运行到 yield 挂起协同程序，第一次 resume 返回（此处 yield 返回，参数是 resume 的参数）。 第二次 resume，再次唤醒协同程序（此处resume的参数中，除了第一个参数，剩下的参数将作为yield的参数）。 协同程序运行，运行到 yield 挂起协同程序，第二次 resume 返回。 协同程序继续运行，重复如上步骤。 如果协同程序运行完成后，继续调用 resume 方法则输出：cannot resume dead coroutine resume 和 yield 的配合强大之处在于 resume 处于主程中，它将外部状态（数据）传入到协同程序内部。 yield 则将内部的状态（数据）返回到主程中。 四、生产者-消费者问题 使用 Lua 的协同程序来完成生产者-消费者这一经典问题。 local newProductor function productor() local i = 0 while true do i = i + 1 send(i) -- 将生产的物品发送给消费者 end end function consumer() while true do local i = receive() -- 从生产者那里得到物品 print('消费者', i) end end function receive() local status, value = coroutine.resume(newProductor) return value end function send(x) coroutine.yield(x) -- x表示需要发送的值，值返回以后，就挂起该协同程序 end -- 启动程序 newProductor = coroutine.create(productor) consumer() 以上实例执行输出结果为： 1 2 3 4 5 6 7 8 9 10 11 12 13 …… 通常会将协同程序与多路程序设计语言的线程进行比较，但需要了解协同程序具有类似的线程功能，但协同程序一次只执行一个程序，并且永远不会同时执行。 通过暂时保留某些信息来控制程序执行顺序以满足需求。使用带有协同程序的全局变量为协同程序提供了更大的灵活性。 powered by Gitbook该文件修订时间： 2019-04-17 21:12:13 "},"base/Lua文件操作.html":{"url":"base/Lua文件操作.html","title":"Lua 文件操作","keywords":"","body":"Lua 文件 I/O 操作 Lua I/O 库用于读取和处理文件，分为两种模式。 隐式文件句柄 或 简单模式：拥有一个当前输入文件和一个当前输出文件，并且提供针对这些文件相关的操作。 显示文件句柄 或 完全模式：使用外部的文件句柄来实现。它以一种面对对象的形式，将所有的文件操作定义为文件句柄的方法 简单模式在做一些简单的文件操作时较为合适。同时读取多个文件这样的操作，使用完全模式则较为合适。 一、语法 -- 打开文件 file = io.open (filename [, mode]) 这个函数用字符串 mode 指定的模式打开一个文件。返回新的文件句柄。当出错时，返回 nil 加错误消息。 mode 字符串可以是下列任意值： r：只读模式，该文件必须存在。 w：可写模式，允许修改已经存在的文件和创建新文件(不可读)。 a：附加模式，用于打开现有文件或创建新文件以进行追加。 r+：读写模式打开已存的在文件。 w+：如果文件已存在则删除文件中数据；若文件不存在则新建文件。读写模式打开。 a+：以可读的追加模式打开已存在文件，若文件不存在则新建文件。 上面的 + 号表示对文件既可以读也可以写。mode 字符串可以在最后加一个 b，这会在某些系统上以二进制方式打开文件。 当文件不存在时 local file = io.open(\"./test.txt\") file:close() 模式\"r\",\"r+\",会提示错误,这两种模式不会自动创建为难。 模式\"a\",\"a+\",\"w\",\"w+\"都会创建文件 三、简单模式 简单模式使用标准的 I/O 或使用一个当前输入文件和一个当前输出文件。 以下为 file.lua 文件代码，假设我的 test.lua 文件里面没有任何内容，代码如下： -- 以只读方式打开文件 file = io.open(\"test.lua\", \"r\") -- 输入文件为 test.lua io.input(file) -- 输出文件第一行 print(io.read()) -- 关闭打开的文件 io.close(file) -- 以附加的方式打开只写文件 file = io.open(\"test.lua\", \"a\") -- 设置输出文件为 test.lua io.output(file) -- 在文件最后一行添加 Lua 注释 io.write(\"-- 文件末尾注释\") -- 关闭打开的文件 io.close(file) 执行以上代码，首次执行无内容输出 nil，并添加一行注释到文件，第二次执行输出 test.lua 文件的第一行信息。 ➜ code-test lua file.lua nil ➜ code-test lua file.lua -- 文件末尾注释 在以上实例中我们使用了 io.\"x\" 方法，其中 io.read() 中我们没有带参数，参数可以是下表中的一种： 模式 描述 示例 \"*n\" 从当前文件位置读取并返回一个数字(如果存在于文件位置或返回nil)。 file.read(\"*n\") \"*a\" 从当前文件位置返回文件的所有内容。 file.read(\"*a\") \"*l\"（默认） 从当前文件位置读取行，并将文件位置移动到下一行。 file.read(\"*l\") number 读取函数中指定的字节数。 file.read(5) 其他的 I/O 方法有： io.tmpfile()：返回一个临时文件句柄，该文件以更新模式打开，程序结束时自动删除。 io.type(file)：检测 obj 是否一个可用的文件句柄。 io.flush()：向文件写入缓冲中的所有数据。 io.lines(optional file name)：返回一个迭代函数，每次调用将获得文件中的一行内容，当到文件尾时，将返 回nil，但不关闭文件 四、完全模式 完全模式：允许一次操作多个文件。这些函数与简单模式非常相似。使用 file:function_name，而不是 io.function_name。 如下示例 -- 以只读方式打开文件 file = io.open(\"test.lua\", \"r\") -- 输出文件第一行 print(file:read()) -- 关闭打开的文件 file:close() -- 以附加的方式打开只写文件 file = io.open(\"test.lua\", \"a\") -- 在文件最后一行添加 Lua 注释 file:write(\"--test\") -- 关闭打开的文件 file:close() read 的参数与简单模式一致。 其他方法: file:seek(optional whence, optional offset)：设置和获取当前文件位，成功则返回最终的文件位置(按字节)，失败则返回 nil 和错误信息。参数 whence 值有如下几个： set：从文件头开始 cur：从当前位置开始[默认] end：从文件尾开始，则定位到文件尾并返回文件大小 offset：默认为0 file:flush()：向文件写入缓冲中的所有数据 io.lines(optional file name)：打开指定的文件 filename 为读模式并返回一个迭代函数，每次调用将获得文件中的一行内容，当到文件尾时，将返回 nil，并自动关闭文件。 以下实例使用了 seek 方法，定位到文件倒数第 25 个位置并使用 read 方法的 *a 参数，即从当期位置(倒数第 25 个位置)读取整个文件。 -- 以只读方式打开文件 file = io.open(\"test.lua\", \"r\") file:seek(\"end\", -25) print(file:read(\"*a\")) -- 关闭打开的文件 file:close() 执行结果 ➜ code-test lua file.lua ?释-- 文件末尾注释 结果中有了一段儿的乱码，这是因为一个字符包含的长度是 3 个，当截取的长度并非刚好读取完整字符时就显示了乱码。比如上面的把 -25 修改为 27 就正常了。 powered by Gitbook该文件修订时间： 2019-04-19 15:56:35 "},"base/Lua错误处理.html":{"url":"base/Lua错误处理.html","title":"Lua 错误处理","keywords":"","body":"Lua 错误处理 程序运行中错误处理是必要的，在我们进行文件操作，数据转移及web service 调用过程中都会出现不可预期的错误。如果不注重错误信息的处理，就会造成信息泄露，程序无法运行等情况。 任何程序语言中，都需要错误处理。错误类型有： 语法错误 运行错误 一、语法错误 语法错误通常是由于对程序的组件（如运算符、表达式）使用不当引起的。一个简单的实例如下： a == 2 以上代码执行结果为： lua: test.lua:2: syntax error near '==' 正如你所看到的，以上出现了语法错误，一个 \"=\" 号跟两个 \"=\" 号是有区别的。一个 \"=\" 是赋值表达式两个 \"=\" 是比较运算。 另外一个实例: for a= 1,10 print(a) end 执行以上程序会出现如下错误： lua: test2.lua:2: 'do' expected near 'print' 语法错误比程序运行错误更简单，运行错误无法定位具体错误，而语法错误我们可以很快的解决，如以上实例我们只要在 for 语句下添加 do 即可： for a= 1,10 do print(a) end 二、运行错误 运行错误是程序可以正常执行，但是会输出报错信息。如下实例由于参数输入错误，程序执行时报错： function add(a,b) return a+b end add(10) 当我们编译运行以下代码时，编译是可以成功的，但在运行的时候会产生如下错误： lua: test2.lua:2: attempt to perform arithmetic on local 'b' (a nil value) stack traceback: test2.lua:2: in function 'add' test2.lua:5: in main chunk [C]: ? 以下报错信息是由于程序缺少 b 参数引起的。 三、错误处理 - 断言和错误功能 我们可以使用两个函数：assert 和 error 来处理错误。 实例如下： 1、assert 函数 local function add(a,b) assert(type(a) == \"number\", \"a 不是一个数字\") assert(type(b) == \"number\", \"b 不是一个数字\") return a+b end add(10) 执行以上程序会出现如下错误： lua: test.lua:3: b 不是一个数字 stack traceback: [C]: in function 'assert' test.lua:3: in local 'add' test.lua:6: in main chunk [C]: in ? 实例中 assert 首先检查第一个参数，若没问题，assert 不做任何事情；否则，assert 以第二个参数作为错误信息抛出。 2、error 函数 语法格式： error (message [, level]) 功能：终止正在执行的函数，并返回 message 的内容作为错误信息(error 函数永远都不会返回) 通常情况下，error 会附加一些错误位置的信息到 message 头部。 Level参数指示获得错误的位置: Level=1[默认]：为调用 error 位置(文件+行号) Level=2：指出哪个调用 error 的函数的函数 Level=0：不添加错误位置信息 四、pcall 和 xpcall 在 Lua 编程中，为了避免抛出这些错误和处理错误，需要使用 pcall 或 xpcall 函数。 pcall(f，arg1，...) 函数在保护模式下调用所请求的函数。如果函数 f 中发生某些错误，则不会抛出错误。它只返回错误状态。 使用 pcall 的一个简单示例如下所示。 function myfunction() n = n/nil end if pcall(myfunction) then print(\"Success\") else print(\"Failure\") end 当构建上面程序时，它将成功构建并运行。运行后，显示运行时错误。 Failure xpcall(f，err) 函数调用所请求的函数，并设置错误处理程序。f 内的任何错误都不会传播; 而 xpcall 只捕获错误，使用原始错误对象调用 err 函数，并返回状态代码。 使用 xpcall 函数的一个简单示例如下所示。 function myfunction() n = n/nil end function myerrorhandler(err) print(\"ERROR:\", err) end status = xpcall(myfunction, myerrorhandler) print(status) 当运行上面的程序时，将得到以下输出。 ERROR: input:2: attempt to perform arithmetic on a nil value (global 'n') false 作为程序员，最重要的是确保在编写的程序中处理正确的错误处理。 使用错误处理可以确保处理超出边界条件的意外条件而不会干扰程序的用户。 powered by Gitbook该文件修订时间： 2019-04-19 23:02:32 "},"base/Lua调试.html":{"url":"base/Lua调试.html","title":"Lua 调试","keywords":"","body":"Lua Debug 调试 Lua 提供了一个调试库，它提供了创建自己的调试器的原始函数。 即使没有内置的 Lua 调试器，也有许多第三方 Lua 调试器，由各种开发人员创建，其中许多是开源的。 一、Debug 函数 （1）debug() 进入用于调试的交互模式，该模式保持活动状态，直到用户只输入一行中的 cont 并按Enter键。 用户可以使用其他功能在此模式下检查变量。 （2）getfenv(object) 返回对象的环境变量。 （3）gethook(optional thread) 返回线程的当前挂钩设置，有三个值：当前挂钩函数，当前挂钩掩码和当前挂钩计数。 （4）getinfo(optional thread, function or stack level, optional flag) 返回一个包含函数信息的表。可以直接给出函数，或者可以给一个数字作为函数的值，在给定线程的调用堆栈的级别函数上运行的函数 级别 0 为当前函数(getinfo本身); 级别 1 为调用 getinfo 的函数; 如果 function 是一个大于活动函数数的数字，则 getinfo 返回 nil。 （5）debug.getlocal([thread,] f, local) 此函数返回在栈的 f 层处函数的索引为 local 的局部变量 的名字和值。这个函数不仅用于访问显式定义的局部变量，也包括形参、临时变量等。 （6）getmetatable(value) 返回给定对象的元表，如果没有元表，则返回 nil。 （7）getregistry() 返回注册表表，这是一个预定义出来的表，可以用来保存任何 C 代码想保存的 Lua 值。 （8）getupvalue(function, upvalue index) 此函数返回 upvalue 的名称和值，索引为函数 func。如果给定索引没有 upvalue，则函数返回 nil。 （9）setupvalue(f, up, value) 这个函数将 value 设为函数 f 的第 up 个上值。 如果函数没有那个上值，返回 nil 否则，返回该上值的名字。 （9）setfenv(function or thread or userdata, environment table) 将给定对象的环境设置为给定表，返回对象。 （10）sethook(optional thread, hook function, hook mask string with \"c\" and/or \"r\" and/or \"l\", optional instruction count) 将给定函数设置为钩子。字符串 mask 以及数字 count 决定了钩子将在何时调用。 掩码是由下列字符组合成的字符串，每个字符有其含义： 'c'：每当 Lua 调用一个函数时，调用钩子； 'r'：每当 Lua 从一个函数内返回时，调用钩子； 'l'：每当 Lua 进入新的一行时，调用钩子。 （11）ssetlocal(optional thread, stack level, local index, value) 将 value 赋这个函数的第 level 级别函数的第 local 个局部变量。如果没有那个变量，函数返回 nil 。 如果 level 越界，抛出一个错误。 setmetatable(value, table) 将 value 的元表设为 table （可以是 nil）。 返回 value。 tracebacks([thread,] [message [, level]]) 如果 message 有，且不是字符串或 nil，函数不做任何处理直接返回 message。否则，返回调用栈的栈回溯信息。 字符串可选项 message 被添加在栈回溯信息的开头。数字可选项 level 指明从栈的哪一层开始回溯 （默认为 1，即调用 traceback 的那里）。 二、示例 function myfunction () print(debug.traceback(\"Stack trace\")) print(debug.getinfo(1)) print(\"Stack trace end\") return 10 end myfunction () print(debug.getinfo(1)) 执行结果 ➜ code-test lua test.lua Stack trace stack traceback: test.lua:2: in function 'myfunction' test.lua:7: in main chunk [C]: in ? table: 0x7ff4cc500580 Stack trace end table: 0x7ff4cc407130 在上面的示例程序中，使用调试库中提供的 debug.trace 函数打印堆栈跟踪。debug.getinfo 获取函数的当前表。 三、示例 调试示例开发人员经常为了知道函数的局部变量以进行调试。 为此，可以使用 getupvalue 和使用 setupvalue 并设置这些局部变量。 一个简单的例子如下所示。 function newCounter () local n = 0 local k = 0 return function () k = n n = n + 1 return n end end counter = newCounter () print(counter()) --> 1 print(counter()) --> 2 local i = 1 repeat name, val = debug.getupvalue(counter, i) if name then print(\"index\", i, name, \"=\", val) if(name == \"n\") then debug.setupvalue(counter, 2, 10) end i = i + 1 end until not name print(counter()) 执行结果 1 2 index 1 k = 1 index 2 n = 2 11 在此示例中，计数器每次调用时都会更新一次。可以使用 getupvalue 函数查看局部变量的当前状态。然后将局部变量设置为新值。这里，在调用 set 操作之前 n 为 2。使用 setupvalue 函数，它更新为 10。现在当调用计数器函数时，它将返回 11 而不是 3。 四、调试类型 命令行调试 图形界面调试 命令行调试 命令行调试是使用命令和打印语句在命令行进行调试的调试类型。 Lua 有许多命令行调试器，下面列出了一些。 RemDebug：它是 Lua 5.0 和 Lua 5.1 的远程调试器。它允许远程控制另一个Lua程序的执行，设置断点并检查程序的当前状态。它还可以调试 CGILua 脚本。 clidebugger：它是 Lua 5.1 的简单命令行界面调试器，用纯Lua编写。除了标准的 Lua 5.1 库之外，它不依赖于任何其他东西。它的灵感来自 RemDebug，但没有远程工具。 ctrace：用于跟踪Lua API调用的工具。 xdbLua：用于Windows平台的简单Lua命令行调试程序。 LuaInterface Debugger：它是 LuaInterface 的调试器扩展。它将内置的Lua调试接口提升到更高的级别。与调试器的交互由事件和方法调用完成。 Rldb：它是一个通过套接字的远程Lua调试器，可在 Windows 和 Linux 上使用。它可以为您提供比现有功能更多的功能。 ModDebug：这允许远程控制另一个Lua程序的执行，设置断点，并检查程序的当前状态。 图形调试 在IDE下可以进行图形调试，在IDE中可为各种状态（如变量值，堆栈跟踪和其他相关信息）进行可视化调试。借助断点，步入，步进和IDE中的其他按钮，可以实现可视化表示和逐步控制执行。 Lua有许多图形调试器，下面列出了一些。 SciTE：Lua 的默认 Windows IDE 提供了多个调试工具，如断点，步骤，步入，步进，监视变量等。 Decoda：这是一个具有远程调试支持的图形调试器。 ZeroBrane Studio：Lua IDE 集成了远程调试器，堆栈视图，监视视图，远程控制台，静态分析器等。适用于 LuaJIT，Love2d，Moai 和其他Lua引擎; Windows，OSX和Linux。 akdebugger：这是Eclipse调试器和编辑器的Lua插件。 luaedit：这包括远程调试，本地调试，语法突出显示，完成建议列表，参数命题引擎，高级断点管理（包括断点和命中计数的条件系统），功能列表，全局和局部变量列表，监视，面向解决方案的管理。 powered by Gitbook该文件修订时间： 2019-04-22 17:17:09 "},"base/Lua垃圾收集.html":{"url":"base/Lua垃圾收集.html","title":"Lua 垃圾收集","keywords":"","body":"Lua 垃圾收集 Lua 使用自动内存管理，该管理使用基于 Lua 内置的某些算法的垃圾收集。自动内存管理收集，作为开发人员无需担心为对象分配内存。除非将其设置为零，否则无需在不再需要时释放它们。 Lua 使用垃圾收集器它在后台会时不时地运行，收集和销毁 Lua 程序访问的死对象。 包括表，用户数据，函数，线程，字符串等在内的所有对象都需要进行自动内存管理。 Lua使用增量标记和扫描收集器，它使用两个数字来控制其垃圾收集周期，即垃圾收集器暂停和垃圾收集器步骤倍增器。 这些值以百分比表示，值 100 通常在内部等于 1。 一、垃圾收集器暂停 垃圾收集器暂停用于控制垃圾收集器之前需要等待多长时间; Lua 的自动内存管理再次调用。小于 100 的值意味着 Lua 不会等待下一个周期。类似地，该值的较高值将导致垃圾收集器缓慢。200 的值表示收集器在开始新循环之前等待使用的总内存加倍。因此，根据应用程序的性质和速度，可能需要更改此值以在 Lua 应用程序中获得最佳性能。 二、垃圾收集器步骤乘数 此步骤乘数控制垃圾收集器与 Lua 程序中内存分配的相对速度。较大的步长值将导致垃圾收集器更具侵略性，并且还会增加垃圾收集的每个增量步骤的步长。小于 100 的值通常可以避免垃圾收集器不完成循环并且通常不是优选的。默认值为 200，这意味着垃圾收集器的运行速度是内存分配的两倍。 三、垃圾回收器函数 作为开发人员，确实可以控制 Lua 中的自动内存管理。有以下方法可以使用。 Lua 提供了以下函数 collectgarbage ([opt [, arg]]) 用来控制自动内存管理: collectgarbage(\"collect\")：运行一个完整的垃圾收集循环。 collectgarbage(\"count\")：返回程序当前以千字节 k 为单位的内存量。 collectgarbage(\"restart\")：如果垃圾收集器已停止，则重新启动它。 collectgarbage(\"setpause\")：将给定的值作为第二个参数除以 100，将它设置为垃圾收集器暂停变量。 collectgarbage(\"setstepmul\")：将给定的值作为第二个参数除以 100，将它设置为垃圾步骤乘数变量。 collectgarbage(\"step\")：运行垃圾收集的一步。第二个参数越大，此步骤越大。如果触发的步骤是垃圾收集周期的最后一步，则 collectgarbage 将返回 true。 collectgarbage(\"stop\")：如果垃圾收集器正在运行，则停止它。 使用垃圾收集器示例如下所示。 mytable = {\"apple\", \"orange\", \"banana\"} print(collectgarbage(\"count\")) mytable = nil print(collectgarbage(\"count\")) print(collectgarbage(\"collect\")) print(collectgarbage(\"count\")) 当运行上面的程序时，将得到以下输出。请注意，由于操作系统类型的不同以及 Lua 的自动内存管理功能，此结果会有所不同。 23.6669921875 23.7744140625 0 23.0810546875 在上面的程序中看到，完成垃圾收集，它就减少了使用的内存。但是，这并不是强制要求。即使不调用它们，它也会在预定义的时间段后由Lua解释器在稍后阶段自动执行。 显然，如果需要，可以使用这些函数来改变垃圾收集器的行为。这些函数为开发人员提供了一些额外的功能来处理复杂的情况。根据程序所需的内存类型，也可能不会使用此功能。但了解应用程序中的内存使用情况并在编程期间检查它以避免在部署后出现意外结果非常有用。 powered by Gitbook该文件修订时间： 2019-04-22 17:30:47 "},"base/Lua面向对象编程.html":{"url":"base/Lua面向对象编程.html","title":"Lua 面向对象编程","keywords":"","body":"Lua 面向对象编程 面向对象编程（Object Oriented Programming，OOP）是一种非常流行的计算机编程架构。 以下几种编程语言都支持面向对象编程： C++ Java Objective-C Smalltalk C# Ruby 一、面向对象的特点 类：类是用于创建对象的可扩展模板，为状态(成员变量)和行为实现提供初始值。 对象：它是类的一个实例，并为自己分配了单独的内存。 继承：这是一个概念，通过该概念，一个类的变量和函数由另一个类继承。 封装：这是在类中组合数据和函数的过程。借助函数可以在类的外部访问数据。 它也被称为数据抽象。 二、Lua 面向对象 我们知道，对象由属性和方法组成。Lua 中最基本的结构是 table，所以需要用 table 来描述对象的属性。 Lua 中 function 可以用来表示方法。那么类就可以通过 table + function 模拟出来。 至于继承，可以通过 metetable 模拟出来（不推荐用，只模拟最基本的对象大部分时间够用了）。 Lua 中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量），也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象； 三、面向对象示例 考虑一个简单的数学例子。我们经常遇到处理不同形状的情况，如圆形，矩形和方形。 形状可以具有共同的属性 area。因此，使用公共属性区域从基础对象形状扩展其他形状。每个形状都可以有自己的属性，像矩形这样的函数可以具有属性 length，width，area 作为属性，printArea 和 calculateArea 作为它的函数。 1、创建一个简单的类 下面显示了具有三个属性 length，width 和 area 的矩形的简单类实现。它还有一个 printArea 函数来打印计算区域面积。 -- Meta class Rectangle = {area = 0, length = 0, breadth = 0} -- 派生类的方法 new function Rectangle:new(o, length, breadth) o = o or {} setmetatable(o, self) self.__index = self self.length = length or 0 self.breadth = breadth or 0 self.area = length * breadth; return o end -- 派生类的方法 printArea function Rectangle:printArea () print(\"矩形面积为 \", self.area) end 2、创建一个对象 创建对象是为类实例分配内存的过程。每个对象都有自己的内存并共享公共类数据。 r = Rectangle:new(nil,10,20) 3、访问属性 可以使用点(.)运算符访问类中的属性。 print(r.length) 4、访问成员函数 使用带有对象的冒号(:)运算符访问成员函数。 r = Rectangle:new(nil,10,20) r:printArea() 分配内存并设置初始值。 5、完整实例 以下我们演示了 Lua 面向对象的完整实例： -- Meta class Rectangle = {area = 0, length = 0, breadth = 0} -- 派生类的方法 new function Rectangle:new(o, length, breadth) o = o or {} setmetatable(o, self) self.__index = self self.length = length or 0 self.breadth = breadth or 0 self.area = length * breadth; return o end -- 派生类的方法 printArea function Rectangle:printArea () print(\"矩形面积为 \", self.area) end -- 创建对象 myshape = Rectangle:new(nil, 10, 20) -- 执行成员函数 myshape:printArea() 执行以上程序，输出结果为： 面积为 200 四、Lua 继承 继承是指一个对象直接使用另一对象的属性和方法。可用于扩展基础类的属性和方法。 以下演示了一个简单的继承实例： -- Meta class Shape = {area = 0} -- 基础类方法 new function Shape:new(o, side) o = o or {} setmetatable(o, self) self.__index = self side = side or 0 self.area = side * side; return o end -- 基础类方法 printArea function Shape:printArea () print(\"面积为 \",self.area) end 接下来的实例，Square 对象继承了 Shape 类: Square = Shape:new() -- 派生新类 function Square:new (o, side) o = o or Shape:new(o,side) setmetatable(o, self) self.__index = self return o end 完整实例 以下实例我们继承了一个简单的类，来扩展派生类的方法，派生类中保留了继承类的成员变量和方法。 -- Meta class Shape = {area = 0} -- 基础类方法 new function Shape:new (o,side) o = o or {} setmetatable(o, self) self.__index = self side = side or 0 self.area = side*side; return o end -- 基础类方法 printArea function Shape:printArea () print(\"面积为 \",self.area) end -- 创建对象 myshape = Shape:new(nil,10) myshape:printArea() Square = Shape:new() -- 派生类方法 new function Square:new (o,side) o = o or Shape:new(o,side) setmetatable(o, self) self.__index = self return o end -- 派生类方法 printArea function Square:printArea () print(\"正方形面积为 \",self.area) end -- 创建对象 mysquare = Square:new(nil,10) mysquare:printArea() Rectangle = Shape:new() -- 派生类方法 new function Rectangle:new (o,length,breadth) o = o or Shape:new(o) setmetatable(o, self) self.__index = self self.area = length * breadth return o end -- 派生类方法 printArea function Rectangle:printArea () print(\"矩形面积为 \",self.area) end -- 创建对象 myrectangle = Rectangle:new(nil,10,20) myrectangle:printArea() 执行以上代码，输出结果为： 面积为 100 正方形面积为 100 矩形面积为 200 在上面的例子中，创建了两个派生类：Square 和 Rectangle。并在派生类中覆盖基类的函数。在此示例中，派生类会覆盖函数 printArea。 函数重写 Lua 中我们可以重写基础类的函数，在派生类中定义自己的实现方式： -- 派生类方法 printArea function Square:printArea () print(\"正方形面积 \", self.area) end powered by Gitbook该文件修订时间： 2019-04-22 19:03:50 "},"base/LuaMySQL操作.html":{"url":"base/LuaMySQL操作.html","title":"Lua MySQL操作","keywords":"","body":"Lua MySQL操作 对于简单的数据操作，可使用文件处理。但有时，这些文件操作可能效率不高，可扩展且功能强大，为此经常需要使用数据库。 一、LuaSQL 介绍 LuaSQL 是一个从 Lua 到 DBMS 的简单接口。 它使Lua程序能够： 连接到 ODBC，ADO，Oracle，MySQL，SQLite，Firebird 和 PostgreSQL 数据库; 执行任意SQL语句; 以逐行光标方式检索结果。 LuaSQL是免费软件，使用与Lua 5.1相同的许可证。 LuaSQL 可以使用 LuaRocks 来安装可以根据需要安装你需要的数据库驱动。 LuaRocks 官网：https://luarocks.org/ LuaSQL 官网：http://keplerproject.github.io/luasql/ LuaSQL GitHub：https://github.com/keplerproject/luasql 二、LuaRocks 安装 Linux 环境 # 下载 $ wget http://luarocks.org/releases/luarocks-2.2.1.tar.gz # 解压 $ tar zxpf luarocks-2.2.1.tar.gz # 进入 $ cd luarocks-2.2.1 # 编译 $ ./configure; sudo make bootstrap # 安装 $ sudo luarocks install luasocket # lua 命令行 $ lua Lua 5.3.0 Copyright (C) 1994-2015 Lua.org, PUC-Rio > require \"socket\" > Window 环境 Window 下安装 LuaRocks：https://github.com/keplerproject/luarocks/wiki/Installation-instructions-for-Windows 三、安装不同数据库驱动： luarocks install luasql-sqlite3 luarocks install luasql-postgres luarocks install luasql-mysql luarocks install luasql-sqlite luarocks install luasql-odbc 你也可以使用源码安装方式，Lua Github 源码地址：https://github.com/keplerproject/luasql 四、Lua 连接MySql 数据库： require \"luasql.mysql\" --创建环境对象 env = luasql.mysql() --连接数据库 conn = env:connect(\"erp\",\"yklyx\",\"99ykTour!99YingK\",\"192.168.128.36\",3306) --设置数据库的编码格式 conn:execute\"SET NAMES UTF8\" --执行数据库操作 cur = conn:execute(\"select * from bom_applied\") row = cur:fetch({}, \"a\") --文件对象的创建 file = io.open(\"role.txt\",\"w+\"); while row do var = string.format(\"%d %s\\n\", row.id, row.name) print(var) file:write(var) row = cur:fetch(row,\"a\") end file:close() --关闭文件对象 conn:close() --关闭数据库连接 env:close() --关闭数据库环境 powered by Gitbook该文件修订时间： 2019-04-22 19:47:42 "}}