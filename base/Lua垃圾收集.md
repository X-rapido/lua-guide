## Lua 垃圾收集
Lua 使用自动内存管理，该管理使用基于 Lua 内置的某些算法的垃圾收集。自动内存管理收集，作为开发人员无需担心为对象分配内存。除非将其设置为零，否则无需在不再需要时释放它们。

Lua 使用垃圾收集器它在后台会时不时地运行，收集和销毁 Lua 程序访问的死对象。

包括表，用户数据，函数，线程，字符串等在内的所有对象都需要进行自动内存管理。 Lua使用增量标记和扫描收集器，它使用两个数字来控制其垃圾收集周期，即垃圾收集器暂停和垃圾收集器步骤倍增器。 这些值以百分比表示，值 `100` 通常在内部等于 `1`。

### 一、垃圾收集器暂停
垃圾收集器暂停用于控制垃圾收集器之前需要等待多长时间; 

Lua 的自动内存管理再次调用。小于 `100` 的值意味着 Lua 不会等待下一个周期。类似地，该值的较高值将导致垃圾收集器缓慢。`200` 的值表示收集器在开始新循环之前等待使用的总内存加倍。因此，根据应用程序的性质和速度，可能需要更改此值以在 Lua 应用程序中获得最佳性能。

### 二、垃圾收集器步骤乘数
此步骤乘数控制垃圾收集器与 Lua 程序中内存分配的相对速度。较大的步长值将导致垃圾收集器更具侵略性，并且还会增加垃圾收集的每个增量步骤的步长。小于 `100` 的值通常可以避免垃圾收集器不完成循环并且通常不是优选的。默认值为 `200`，这意味着垃圾收集器的运行速度是内存分配的两倍。

### 三、垃圾回收器函数
作为开发人员，确实可以控制 Lua 中的自动内存管理。有以下方法可以使用。

Lua 提供了以下函数 `collectgarbage ([opt [, arg]])` 用来控制自动内存管理:

- `collectgarbage("collect")`：运行一个完整的垃圾收集循环。
- `collectgarbage("count")`：返回程序当前以千字节 k 为单位的内存量。
- `collectgarbage("restart")`：如果垃圾收集器已停止，则重新启动它。
- `collectgarbage("setpause")`：将给定的值作为第二个参数除以 100，将它设置为垃圾收集器暂停变量。
- `collectgarbage("setstepmul")`：将给定的值作为第二个参数除以 100，将它设置为垃圾步骤乘数变量。
- `collectgarbage("step")`：运行垃圾收集的一步。第二个参数越大，此步骤越大。如果触发的步骤是垃圾收集周期的最后一步，则 collectgarbage 将返回 true。
- `collectgarbage("stop")`：如果垃圾收集器正在运行，则停止它。

使用垃圾收集器示例如下所示。
```lua
mytable = {"apple", "orange", "banana"}
print(collectgarbage("count"))
mytable = nil

print(collectgarbage("count"))
print(collectgarbage("collect"))
print(collectgarbage("count"))
```
当运行上面的程序时，将得到以下输出。请注意，由于操作系统类型的不同以及 Lua 的自动内存管理功能，此结果会有所不同。
```
23.6669921875
23.7744140625
0
23.0810546875
```
在上面的程序中看到，完成垃圾收集，它就减少了使用的内存。但是，这并不是强制要求。即使不调用它们，它也会在预定义的时间段后由Lua解释器在稍后阶段自动执行。

显然，如果需要，可以使用这些函数来改变垃圾收集器的行为。这些函数为开发人员提供了一些额外的功能来处理复杂的情况。根据程序所需的内存类型，也可能不会使用此功能。但了解应用程序中的内存使用情况并在编程期间检查它以避免在部署后出现意外结果非常有用。

