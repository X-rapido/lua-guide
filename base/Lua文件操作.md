## Lua 文件 I/O 操作
Lua `I/O` 库用于读取和处理文件，分为两种模式。
- **隐式文件句柄 或 简单模式**：拥有一个当前输入文件和一个当前输出文件，并且提供针对这些文件相关的操作。
- **显示文件句柄 或 完全模式**：使用外部的文件句柄来实现。它以一种面对对象的形式，将所有的文件操作定义为文件句柄的方法

简单模式在做一些简单的文件操作时较为合适。同时读取多个文件这样的操作，使用完全模式则较为合适。

## 一、语法
```lua
-- 打开文件
file = io.open (filename [, mode])
```
这个函数用字符串 `mode` 指定的模式打开一个文件。返回新的文件句柄。当出错时，返回 `nil` 加错误消息。

`mode` 字符串可以是下列任意值：
- 
- `r`：只读模式，该文件必须存在。
- `w`：可写模式，允许修改已经存在的文件和创建新文件(不可读)。
- `a`：附加模式，用于打开现有文件或创建新文件以进行追加。
- `r+`：读写模式打开已存的在文件。
- `w+`：如果文件已存在则删除文件中数据；若文件不存在则新建文件。读写模式打开。
- `a+`：以可读的追加模式打开已存在文件，若文件不存在则新建文件。

上面的 `+` 号表示对文件既可以读也可以写。`mode` 字符串可以在最后加一个 `b`，这会在某些系统上以二进制方式打开文件。

### 当文件不存在时
```
local file = io.open("./test.txt")
file:close()
```
- 模式"r","r+",会提示错误,这两种模式不会自动创建为难。
- 模式"a","a+","w","w+"都会创建文件


### 三、简单模式
简单模式使用标准的 I/O 或使用一个当前输入文件和一个当前输出文件。

以下为 `file.lua` 文件代码，假设我的 `test.lua` 文件里面没有任何内容，代码如下：
```lua
-- 以只读方式打开文件
file = io.open("test.lua", "r")

-- 输入文件为 test.lua
io.input(file)

-- 输出文件第一行
print(io.read())

-- 关闭打开的文件
io.close(file)

-- 以附加的方式打开只写文件
file = io.open("test.lua", "a")

-- 设置输出文件为 test.lua
io.output(file)

-- 在文件最后一行添加 Lua 注释
io.write("-- 文件末尾注释")

-- 关闭打开的文件
io.close(file)
```

执行以上代码，首次执行无内容输出 `nil`，并添加一行注释到文件，第二次执行输出 `test.lua` 文件的第一行信息。
```lua
➜  code-test lua file.lua
nil
➜  code-test lua file.lua
-- 文件末尾注释
```

在以上实例中我们使用了 `io.`"x" 方法，其中 `io.read()` 中我们没有带参数，参数可以是下表中的一种：

| 模式           | 描述                                                            | 示例              |
| -------------- | --------------------------------------------------------------- | ----------------- |
| `"*n"`         | 从当前文件位置读取并返回一个数字(如果存在于文件位置或返回nil)。 | `file.read("*n")` |
| `"*a"`         | 从当前文件位置返回文件的所有内容。                              | `file.read("*a")` |
| `"*l"`（默认） | 从当前文件位置读取行，并将文件位置移动到下一行。                | `file.read("*l")` |
| `number`       | 读取函数中指定的字节数。                                        | `file.read(5)`    |

其他的 I/O 方法有：
- `io.tmpfile()`：返回一个临时文件句柄，该文件以更新模式打开，程序结束时自动删除。
- `io.type(file)`：检测 obj 是否一个可用的文件句柄。
- `io.flush()`：向文件写入缓冲中的所有数据。
- `io.lines(optional file name)`：返回一个迭代函数，每次调用将获得文件中的一行内容，当到文件尾时，将返 回nil，但不关闭文件

### 四、完全模式
完全模式：允许一次操作多个文件。这些函数与简单模式非常相似。使用 `file:function_name`，而不是 `io.function_name`。

如下示例
```lua
-- 以只读方式打开文件
file = io.open("test.lua", "r")

-- 输出文件第一行
print(file:read())

-- 关闭打开的文件
file:close()

-- 以附加的方式打开只写文件
file = io.open("test.lua", "a")

-- 在文件最后一行添加 Lua 注释
file:write("--test")

-- 关闭打开的文件
file:close()
```

`read` 的参数与简单模式一致。

其他方法:
- `file:seek(optional whence, optional offset)`：设置和获取当前文件位，成功则返回最终的文件位置(按字节)，失败则返回 `nil` 和错误信息。参数 `whence` 值有如下几个：
  - `set`：从文件头开始
  - `cur`：从当前位置开始[默认]
  - `end`：从文件尾开始，则定位到文件尾并返回文件大小
  - `offset`：默认为0
- `file:flush()`：向文件写入缓冲中的所有数据
- `io.lines(optional file name)`：打开指定的文件 `filename` 为读模式并返回一个迭代函数，每次调用将获得文件中的一行内容，当到文件尾时，将返回 `nil`，并自动关闭文件。

以下实例使用了 `seek` 方法，定位到文件倒数第 `25` 个位置并使用 `read` 方法的 `*a` 参数，即从当期位置(倒数第 25 个位置)读取整个文件。
```lua
-- 以只读方式打开文件
file = io.open("test.lua", "r")

file:seek("end", -25)
print(file:read("*a"))

-- 关闭打开的文件
file:close()
```

执行结果
```lua
➜  code-test lua file.lua
?释-- 文件末尾注释
```
结果中有了一段儿的乱码，这是因为一个字符包含的长度是 `3` 个，当截取的长度并非刚好读取完整字符时就显示了乱码。比如上面的把 `-25` 修改为 `27` 就正常了。
